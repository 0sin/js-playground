<!DOCTYPE html>
<html lang="kr">
<head>
  <meta charset="UTF-8">
  <title>js Playground | 총정리 복습</title>
  <style>
    * {box-sizing: border-box;}
    h1 {display: inline-flex;}
    h2 {color: orangered;}
    h3 {color: blue;}
    p {margin-left: 10px;}
    .idx-box, .idx {list-style: none; margin: 0; padding: 0;}
    .idx-box {display: inline-flex; margin: 0 0 0 20px; }
    .idx {
      text-align: center; font-size: 15px; line-height: 25px;
      width: 30px; height: 30px; padding: 3px; margin-left: 6px; color: white;
      border-radius: 100%; background-color: cornflowerblue; cursor: pointer;
      }
    
  </style>
</head>

<body>
  <h1>js Playground 총정리 복습</h1>
  <ul class="idx-box">
    <li class="idx">1</li>
    <li class="idx">2</li>
    <li class="idx">3</li>
    <li class="idx">4</li>
    <li class="idx">5</li>
    <li class="idx">6</li>
    <li class="idx">7</li>
  </ul>

  <!-- 1. 구구단 준비 -->
  <div class="chapter">
    <h2>1. 구구단 준비</h2>

    <h3>몇 시 인가요?</h3>
    <p id="time"></p><br><br>
    <script>
      let time = document.getElementById('time');
      time.innerHTML = Date();
      let size = 10;
      function big() {
        time.style.fontSize = size + "px";
        size += 1;
        if(size === 50) {size = 10;}
      }
      // let tid = setInterval(big, 100);
    </script>


    <h3>자료형</h3>
    <p>어떤 종류의 데이터를 사용하는 것이지 컴퓨터에게 알려주는 것</p>
    <p>자료형마다 사용 가능한 연산자(Operator)를 따로 가지고 있습니다!</p>
    <p>자료형이 같아야 연산을 할 수 있습니다!</p>
    
    <ul>
      <li>Number</li>
      <li>String : Immutable 속성을 가진다.</li>
      <li>Boolean</li>
      <li>Null</li>
      <li>Undefined</li>
    </ul>
    <br>
    
    <h3>typeof 연산자</h3><br><br>
    <script>
      console.log(10 / 3); //3.3333333333333335
      console.log(0.1 + 0.2); //0.30000000000000004
      console.log(typeof 10);
      console.log(typeof "10");
      console.log(!(true && false)); //true
    </script>
    
    <h3>변수</h3>
    <p>데이터(값)를 담을 수 있는 그릇입니다. 데이터들은 컴퓨터의 메모리의 어딘가에 저장되는데 그 값들을 구별짓고 재사용하기 위해서 변수를 씁니다.</p>
    <b>변수와 대입 연산자</b>
    <p>변수에 값을 넣고 싶을 때 = 연산자를 사용한다! =은 수학에서의 같다가 아니라 변수에 값을 할당할 때 사용하는 대입 연산자입니다. 같다는 ===을 주로 사용합니다.</p><br><br>
    

    <h3>연산자</h3>
    <b>증감연산자</b>
    <p>C언어의 잔재인데 조금 쓸데없이 복잡합니다. 우리는 a++; 스타일만 사용합시다.</p>
    <script>
      let y; //undifined
      y++
      console.log(y) // NaN
      y=10;
      y++
      console.log(y) // 11

    </script>
    
    <b>비교연산자</b>
    <p>비교 연산자를 수행한 결과값은 Boolean입니다. 비교 연산자에는 >, <, >=, <=, ===, != 등이 있습니다.</p>
    <em>. 연산자는 객체의 속성을 가져올 때 사용하는 연산자. (-의) 처럼 읽을 수 있다.</em><br><br><br>

    <h3>문자열 조작</h3>
    <b>문자열 길이 구하기</b>
    <p>let a = "hello"</p>
    <p>a.length;</p>

    <b>문자열 간단한 조작(함수=메소드)</b>
    <p>a.slice(1,4) : 1이 시작, 4가 끝. 4는 포함하지 않음.</p>
    <p>a.toUpperCase() / a.toLowerCase() :</p>

    <b>alert()과 prompt()</b>
    <p>let ans = prompt("숫자를 입력하세요") : 입력값이 ans로 들어감. 숫자가 입력되어도 문자열로 인식되기 때문에 Number(ans)로 바꿔줘야 함.</p>
    <p>alert(ans) : 경고창</p> <br><br>

    <script>
      let bts = "방탄소년단";
      console.log(bts[0], bts[1]);
      
      bts[2] ="청";
      console.log(bts); //Immutable
      
      let bts2 = bts.slice(1, 3);
      console.log(bts); //Immutable 속성이기 때문에 원본을 바꾸지 않음.
      console.log(bts2); //탄소

      /*
      let ans = prompt("숫자를 입력하세요");
      console.log(typeof ans); //string
      console.log(Number(ans)); //숫자
      console.log(typeof Number(ans)); //string

      alert(ans); // prompt에서 온 ans의 값을 띄워줌.
      */
    </script>

    <script>
      
      /*
      // 연습문제 1-1 : 두 수를 입력받아 사칙연산의 결과를 표시해 봅시다.
          var s1 = prompt("숫자1을 입력해 주세요.");
          var s2 = prompt("숫자2를 입력해 주세요.");
          var n1 = Number(s1);
          var n2 = Number(s2);
          console.log(n1 + "+" + n2 + " = " + (n1 + n2));
          console.log(n1 + "-" + n2 + " = " + (n1 - n2));
          console.log(n1 + "*" + n2 + " = " + (n1 * n2));
          console.log(`${n1}/${n2} = ${n1 / n2}`);
      // 연습문제 1-2 : BMI를 계산하는 프로그램을 작성해 봅시다.
          var s1 = prompt("키을 입력해 주세요. (cm)");
          var s2 = prompt("체중을 입력해 주세요.(Kg)");
          var height = Number(s1) / 100;
          var weight = Number(s2);
          var bmi = weight / (height * height);
          document.write("BMI는 "  + bmi +"입니다.");
      
      // 연습문제 1-3 : 화씨를 입력받아서 섭씨로 바꾸는 프로그램을 작성해 봅시다.
          //32f = 0c, 212f = 100c
          var s1 = prompt("화씨온도를 입력해 주세요.(F)");        
          var f = Number(s1);        
          var c = (f - 32) * 5 / 9;
          document.write("화씨" + f  + "도는 섭씨 "  + c + "도입니다.");
      
      // 연습문제 1-4 : 입력한 문자열의 길이를 알려주는 프로그램을 작성해 봅시다.
          var s1 = prompt("아무 말이나 넣어 주세요.");        
          var len = s1.length;
          document.write(s1 + "의 길이는 "  + len + "입니다.");
      */
    
    </script>

    <h2>조건문 + 반복문 = 제어문</h2>
    <h3>if 조건문</h3>
    <b>if 기본 문법</b>
    <pre>if (조건식1) {
      //조건식이 참일 경우 실행
    } else if(조건식2)  {
      //조건식1은 거짓이고 2는 참일 경우
    } else {
      //거짓일 경우 실행
    }</pre>
    <p>{}는 생략할 수 있지만 꼭 쓰는 게 좋다.</p>
    <p>indent(들여쓰기)를 예쁘게 해야 한다. (필수!)</p> <br><br>

    <h3>반복문</h3>
    <b>While 반복문</b>
    <pre>while(조건) {
      console.log("참일때 실행됨");
    }</pre>

    <b>for 반복문</b>
    <pre>for (var i = 0; i <= 100; i++) {
          console.log(i);
    }</pre><br><br>
    <script>
      // while 문을 사용해서 1에서 100까지의 합을 구해 봅시다.
      var j = 1; //(1)
      var jSum = 0;
      while (j <= 100) { //(2)
        jSum += j; //(3)
        j++; //(4)
      }
      console.log(`1부터 100까지 합은 ${jSum} 입니다.`);
    </script>

    <script>
      /*
      // 연습문제 1 : 사용자가 입력한 수들의 갯수와 합을 구하는 프로그램을 작성해 봅시다. (단 0을 입력받으면 입력 종료)
      var sum = 0;
      var n = -1;
      var count = -1;
      while(n != 0) {
          n = Number(prompt("숫자를 입력해 주세요(0 = 종료)"));
          sum += n;         
          count++;  
          // console.log(count, n, sum);     
      }    

      document.write("입력한 " +  count + "개 수의 합은 " +  sum + "입니다.");


      // 연습문제 2 : 1에서 100까지 짝수의 합을 구해 봅시다.
      var sum = 0;
          for (var i = 1; i <= 100; i++) {
              if (i % 2 == 0) {
                  sum += i;
                  // console.log(i, sum);
              }
      }

      document.write("1부터 100까지 짝수의 합은" +  sum + "입니다.");
      */
    </script>

    <h3>소수 판별 프로그램</h3>
    <pre>
      var ifPrime = true;
      var n = Number(prompt("2이상의 정수를 입력해 주세요."));
      for (var i = 2; i < n ; i++) {
        if (n % i === 0) {
          isPrime = false;
          //break;
        }
      }

      if (isPrime) {
        document.write(n + "은 소수 입니다.");
      } else {
        document.write(n + "은 소수가 아닙니다.");
      }
    </pre>
    <script>
      /*
      var ifPrime = true;
      var n = Number(prompt("2이상의 정수를 입력해 주세요."));
      for (var i = 2; i < n ; i++) {
        if (n % i === 0) {
          isPrime = false;
          console.log(i)
          break; //눈치채야지!
        }
      }

      if (isPrime) {
        document.write(n + "은 소수 입니다.");
      } else {
        document.write(n + "은 소수가 아닙니다.");
      }
      */
    </script>
  </div>
  
  <!-- 2. 구구단 구현 1 -->
  <div class="chapter">
    <h2>2. 구구단 구현 1</h2>
    
    <h3>2, 3단 구현</h3>
    <p>document.write로 구현</p>
    <script>
      document.write(`2단<br>`);
      document.write(`2 * 1 = ${2*1} <br>`);
      document.write(`2 * 2 = ${2*2} <br>`);
      document.write(`2 * 3 = ${2*3} <br>`);
      document.write(`2 * 4 = ${2*4} <br>`);
      document.write(`2 * 5 = ${2*5} <br>`);
      document.write(`2 * 6 = ${2*6} <br>`);
      document.write(`2 * 7 = ${2*7} <br>`);
      document.write(`2 * 8 = ${2*8} <br>`);
      document.write(`2 * 9 = ${2*9} <br>`);
      document.write(`3단<br>`);
      document.write(`3 * 1 = ${3*1} <br>`);
      document.write(`3 * 2 = ${3*2} <br>`);
      document.write(`3 * 3 = ${3*3} <br>`);
      document.write(`3 * 4 = ${3*4} <br>`);
      document.write(`3 * 5 = ${3*5} <br>`);
      document.write(`3 * 6 = ${3*6} <br>`);
      document.write(`3 * 7 = ${3*7} <br>`);
      document.write(`3 * 8 = ${3*8} <br>`);
      document.write(`3 * 9 = ${3*9} <br>`);
    </script>

    <br><br>
    <h3>4단 구현</h3>
    <p>변수 let gugu4 = 4; 사용</p>
    <script>
      let gugu4 = 4;
      document.write(`${gugu4}단<br>`);
      document.write(`${gugu4} * 1 = ${gugu4*1} <br>`);
      document.write(`${gugu4} * 2 = ${gugu4*2} <br>`);
      document.write(`${gugu4} * 3 = ${gugu4*3} <br>`);
      document.write(`${gugu4} * 4 = ${gugu4*4} <br>`);
      document.write(`${gugu4} * 5 = ${gugu4*5} <br>`);
      document.write(`${gugu4} * 6 = ${gugu4*6} <br>`);
      document.write(`${gugu4} * 7 = ${gugu4*7} <br>`);
      document.write(`${gugu4} * 8 = ${gugu4*8} <br>`);
      document.write(`${gugu4} * 9 = ${gugu4*9} <br>`);
    </script>

    <br><br>
    <h3>prompt를 사용해서 X단 구현</h3>
    <script>
      /*
      let guguX = Number(prompt("숫자를 입력해주세요."))
      document.write(`${guguX}단<br>`);
      document.write(`${guguX} * 1 = ${guguX*1} <br>`);
      document.write(`${guguX} * 2 = ${guguX*2} <br>`);
      document.write(`${guguX} * 3 = ${guguX*3} <br>`);
      document.write(`${guguX} * 4 = ${guguX*4} <br>`);
      document.write(`${guguX} * 5 = ${guguX*5} <br>`);
      document.write(`${guguX} * 6 = ${guguX*6} <br>`);
      document.write(`${guguX} * 7 = ${guguX*7} <br>`);
      document.write(`${guguX} * 8 = ${guguX*8} <br>`);
      document.write(`${guguX} * 9 = ${guguX*9} <br>`);
      */
    </script>

    <br><br>
    <h3>While 반복문을 사용</h3>
    <script>
      /*
      let whileUseLoop = Number(prompt("몇 단을 출력할까요?"));
      document.write(`${whileUseLoop}단<br>`);
      let whileLoopIdx = 1;

      while (whileLoopIdx <= 9) {
        document.write(`${whileUseLoop} * 1 = ${whileUseLoop*1} <br>`);
        whileLoopIdx++;
      }
      */
    </script>

    <br><br>
    <h3>Input 값으로 구구단 구현</h3>
    <input type="text" id="inputId" value="">
    <button onclick="myGuGu()">출력</button>
    <script>
      let inputId = document.getElementById('inputId');
      function myGuGu() {
        let myGuGuNum = inputId.value;
        for (let myGuGuIdx=1; myGuGuIdx<=9; myGuGuIdx++) {
          document.write(`${myGuGuNum} * ${myGuGuIdx} = ${myGuGuNum * myGuGuIdx} <br>`);
        }
      }
    </script>

    <br><br>
    <h3>prompt / 조건문 사용</h3>
    <p>입력한 숫자 값이 2이상, 9이하인지 확인</p>
    <script>
      /*
      let promConditionNum = Number(prompt("몇 단을 출력할까요?"));
      document.write(`${promConditionNum}단<br>`);

      if (promConditionNum > 1 && promConditionNum <=9) {
        for (let CondiNum=1; CondiNum<=9; CondiNum++) {
          document.write(`${promConditionNum} * ${CondiNum} = ${promConditionNum * CondiNum} <br>`);
        }
      } else {
        alert('2이상, 9이하의 숫자를 입력해주세요')
      }
      */
    </script>

    <br><br>
    <h3>input / 조건문 사용</h3>
    <p>입력한 숫자 값이 2이상, 9이하인지 확인</p>

    <input type="text" id="inputId2">
    <button onclick="myGuGu2()">출력</button>
    <script>
      function myGuGu2() {
        let inputId2 = document.getElementById('inputId2').value;

        
        if (inputId2 > 1 && inputId2 <=9) {
          document.write(`${inputId2}단<br>`);
          for (let CondiNum=1; CondiNum<=9; CondiNum++) {
            document.write(`${inputId2} * ${CondiNum} = ${inputId2 * CondiNum} <br>`);
          }
        } else {
          document.write('2이상, 9이하의 숫자를 입력해주세요');
        }
      }

    </script>
  </div>

  <!-- 3. 배열, 함수, 객체 -->
  <div class="chapter">
    <h2>3. 배열, 함수, 객체</h2>
    <h3>break</h3>
    <p>break는 반복문을 중간에 빠져나갈 때 사용합니다. 무한 루프와 함께 많이 사용합니다.</p>
    <script>
      /*
      let breakStr;
      while (true) {    
        breakStr = prompt("아무거나 입력하세요");
          document.write(breakStr + "<br>");
          if (breakStr == "q") {
              break;
          }
      }
      document.write("Bye~");
      */

      for(let i = 0;i < 10; i++) {
          if (i == 5) {
              break;
          }
          console.log(i);
      }
    </script>

    <br><br>
    <h3>continue</h3>
    <p>continue는 반복문의 처음으로 돌아갑니다.</p>
    <p>while: 조건식( i < 10 )으로 이동</p>
    <p>for: 증감식 ( i++) 으로 이동</p>
    <script>
      for(var i = 0;i < 10; i++) {
          if (i == 5) {
              continue; //처음으로 돌아가기 때문에 
          }
          console.log(i); //5는 출력되지 않음
      }
    </script>

    <br><br>
    <h3>이중루프</h3>
    <p>반복문 안에 반복문이 있는 걸 이중 루프라고 합니다. 종종 사용합니다. 3중, 4중도 가능하지만 잘 사용하지 않습니다.</p>
    <p>break는 loop를 <b>한번만</b> 빠져나간다</p>
    <script>
      for (var i = 0; i < 2; i++) {
          for (var j = 0; j < 3; j++) {
              console.log(i + ", " +j);
          }
      }

      for (var i = 0; i < 3; i++) {
          for (var j = 0; j < 5; j++) {
              console.log("i= " + i+ ", j= " + j);
              if (j == 2) {
                  break;
              }
          }
      }
    </script>

    <br><br>
    <h3>배열 (Array)</h3>
    <p>자바스크립트에서 가장 많이 사용하는 <b>자료구조</b>의 하나로 ㅡ주로 같은 종류의 값 여러 개를 묶어서 저장하고 관리하기 위해 사용합니다. 참고로 자바스크립트의 배열은 객체입니다. (Array object)</p>
    <script>
      // 배열 만들기 1
      var scores = [50, 60, 70];
      console.log(scores);
      console.log(scores.length);

      // 인덱스를 이용해서 배열의 원소 읽기
      console.log(scores[0]); //50
      console.log(scores[3]); //undifined

      // 배열에 값 쓰기
      scores[0] = 100;
      console.log(scores);
      scores[9] = 5050;
      console.log(scores); //emptyx6도 원소로 쳐줌. length는 10
      
      // 배열의 타입 알아보기
      console.log(typeof scores); //object
      console.log(typeof scores[0]); //number
      
      // 배열 만들기 2
      var a = [];
      a[0] = 2;
      a[1] = 4;
      console.log(a); // [2, 4]

      // 배열의 길이 구하기
      console.log(scores.length);
      
      // 배열의 마지막 원소를 읽어 오려면?
      console.log(scores[scores.length - 1]); //5050
    </script> 
    
    <br><br>
    <h3>문자열과 배열</h3>
    <p>문자열과 배열은 비슷한 성질을 많이 가지고 있습니다.</p>
    <p>문자열: Immutable : 선언된 값을 바꿀수 없음</p>
    <p>배열: Mutable</p>
    <p>배열의 속성과 메소드를 문자열에도 테스트해보세요.</p>
    <script>
      let hiHello = "hiHello";
      console.log(hiHello.length); //7
      console.log(hiHello[0]); //h
      console.log(hiHello[2]); //H
      hiHello[2] = "h"; //대문자로 소문자로 바꾸기
      console.log(hiHello); //안바뀜.
      hiHello[8] = "w";
      console.log(hiHello); //안바뀜.
    </script>

    <br><br>
    <h3>배열의 메소드들 1</h3>
    <b>push(), pop()</b>
    <p>push(value) : 배열의 뒤 쪽에 새로운 원소를 삽입합니다.</p>
    <p>pop(): 배열의 마지막 원소를 빼서 변수에 넣어 줍니다. 이 때 변수의 길이는 1 감소합니다.</p>
    <p>스택(스택은 제한적으로 접근할 수 있는 나열 구조이다. 그 접근 방법은 언제나 목록의 끝에서만 일어난다. 끝먼저내기 목록이라고도 한다. 스택은 한 쪽 끝에서만 자료를 넣거나 뺄 수 있는 선형 구조으로 되어 있다.)처럼 동작하는데 사용합니다. : 접시더미 쌓아서 위에서부터 빼내는것?</p>
    <br>
    <b>shift(), unshift()</b>
    <p>push, pop과 반대로 동작합니다.</p>
    <p>unshift(v): 배열의 맨 앞에 새로운 값을 추가합니다.</p>
    <p>shift(): 배열의 앞에서 값을 빼서 변수에 넣어 줍니다.</p>
    <script>
      let arrMethod = [1, 2, 3, 4];
      console.log(arrMethod); 
      
      arrMethod.push(5);
      arrMethod.push(6);
      console.log(arrMethod);  // [1, 2, 3, 4, 5, 6]
      
      arrMethod.pop();
      console.log(arrMethod); // [1, 2, 3, 4, 5]

      arrMethod.shift();
      console.log(arrMethod); // [2, 3, 4, 5]

      arrMethod.unshift(0);
      console.log(arrMethod);  //[0, 2, 3, 4, 5]
    </script>

    <br><br>
    <h3>함수</h3>
    <p>수학의 함수와 상당히 유사합니다. 매개변수 -> (처리) -> 리턴값의 형태를 가집니다.</p>
    <pre>
      f(x) = 2x + 3
      f(2) = 7
      f(3) = 9

      var foo = function(x) {
          return 2 * x + 3;
      }

      var y= foo(2);
      y = foo(3);
    </pre>
    
    <br>
    <b>함수 만들기 1</b>
    <p>매개 변수도 없고, 리턴값도 없는 가장 단순한 형태의 함수를 만들어 봅시다. 출력과 리턴은 전혀 다르다는 걸 기억하세요.</p>
    <pre>
    var foo = function() {
        console.log("I am function");
    }
    </pre>

    <br>
    <b>함수 호출</b>
    <p>함수를 사용하는 걸 함수 호출(call)이라고 합니다. 함수 이름 + 괄호가 필요합니다.</p>
    <p>foo();</p>

    <br>
    <b>매개변수가 있는 함수 정의하기</b>
    <pre>
    var foo2 = function(name) {
      console.log("hello " + name);
    }
    </pre>

    <br>
    <b>매개변수가 있는 함수 사용해 보기</b>
    <pre>
      foo2("honux");
    </pre>


    <script>
      var foo = function(x) {
          return 2 * x + 3;
      }

      let y00= foo(2);

      console.log(y = foo(3)); //9 //인자 다시 전달
      console.log(y00); //9 변수에 리턴값이 저장됨

      var foo2 = function(name) {
      console.log("hello " + name);
      }

      foo2("0sin"); //console.log 리턴
    </script>

    <br><br>
    <h3>함수와 리턴 값</h3>
    <b>리턴 값이 있는 함수 정의하기</b>
    <p>리턴 값이 있을 경우 함수를 호출해서 변수에 값을 넣을 수 있습니다.</p>
    <pre>
      var five = function() {
        return 5;
      }
      
      var n = five();
      console.log(n);
    </pre>

    <br>
    <b>리턴이 없는 함수를 변수에 할당하면?</b>
    <p>리턴값이 없는 함수를 변수에 넣으면 변수에 값이 없기 때문에 undifined</p>
    <pre>
      var foo = function() {
        console.log(5);
      }
      var n = foo(); //console.log(5); 출력됨
      console.log(n); //undifined
    </pre>

    <br>
    <b>아무 값도 없는 리턴 사용하기</b>
    <p>return 으로 함수를 종료하는데 사용할 수 있다. //루프를 나갈때는 break</p>
    <pre>
      var test1 = function(text) {
        if (text === "exit") {
          return;
        }   
        console.log("보이나요?");    
      }
      
      test1("hoho");
      test1("exit");
    </pre>

    <script>
      var five = function() {
        return 5;
      }
      
      var n00 = five();
      console.log(n00); //5

      var foo00 = function() {
          console.log(5);
      }
      var n0000 = foo00(); //foo00 호출 -> 5출력
      // 라턴값이 없는 함수를 변수에 넣으면 변수에 값이 없기 때문에 undifined
      console.log(n0000); //undifined: return 값이 없기 떄문.

      var test1 = function(text) {
        if (text === "exit") {
          return;
        }   
        console.log("보이나요?");    
      }
      
      test1("hoho"); // 보이나요?
      test1("exit"); //return에 값이 없기 때문에 아무값도 출력되지 않고 함수 종료 
    </script>

    <br>
    <b>함수를 사용하면</b>
    <p>가독성이 좋아짐</p>
    <p>유지보수를 잘 하게 됨</p>

    <br>
    <b>함수 어떻게 만들까?</b>
    <p>매개 변수와 리턴을 적극적으로 활용하자.</p>
    <p>줄 수가 지나치게 길어지면 함수로 빼자. (10줄 정도)</p>
    <p>인덴트가 지나치게 깊어져도 함수로 빼자.</p>
    <p>함수는 반드시 한 가지 일만 하도록 하자.</p>

    <br>
    <b>(Option) 2중 루프를 한 번에 빠져 나가기</b>
    <p>`break` 명령은 한 번에 한 루프만 빠져나갑니다.</p>
    <p>함수의 `return` 을 이용하면 2중 루프를 한 번에 종료할 수 있습니다.</p>

    <br><br>
    <h3>객체의 기초</h3>
    <b>객체란 무엇인가?</b>
    <p>현실의 물체에 대응되는 개념입니다.</p>
    <p>객체를 사용하면 변수와 함수를 묶어서 관리하게 됩니다.</p>
    <p>객체는 속성과 메소드를 가집니다.</p>

    <br>
    <b>객체 만들기</b>
    <p>p1 = {};</p>
    
    <br>
    <b>속성</b>
    <p>객체에 속한 변수</p>
    <pre>
      p1.name = "Hoyoung Jung";
      console.log(p1.name);
    </pre>
    
    <br>
    <b>메소드</b>
    <p>객체에 속한 함수</p>
    <pre>
    p1.eat = function(food) {
      console.log(this.name + " ate delicious " + food + "...");
    };
    
    p1.eat("Beef");
    </pre>
    
    <br>
    <b>메소드 대신에 일반 함수를 썼다면?</b>
    <p>eat(p1, "Beef");</p>
    
    <br>
    <b>객체 지향 프로그래밍</b>
    <p>유지보수가 쉬워진다.</p>
    <p>가독성이 높아진다.</p>
    <p>대형 프로그램을 짜기 쉬워진다.</p>
    
    <br>
    <p>객체와 객체가 협력해서 일을 한다.</p>
    <p>객체는 일에 책임을 진다.</p>
    <p>객체는 객체에 메시지를 보낸다.</p>
    <p>객체는 자율적으로 일을 한다.</p>

    <br>
    <b>this 키워드</b>
    <p>메소드 안에서 사용시 함수를 소유한 객체를 가르킨다.</p>
    <pre>
      var p2 = {};
      p2.name = "crong";
      p2.weight = 80;
      p2.say = function(word) {
          console.log(this.name + " says, " + word);
      };
    </pre>

    <br>
    <b>객체 만들기2</b>
    <p>JSON 표기법을 이용해서 객체를 만들 수도 있습니다. 생성자 함수를 이용하는 방법도 있지만 다음에 다루겠습니다.</p>
    <p>JSON : 자바스크립트 오브젝트 노테이션</p>
    <pre>
      var m1 = {
        "name": "Honux",
        "hp": 100,
        "power": 10,
        "attack": function(target) {
          target.hp -= this.power;
        }
      };
      
      var c1 = {
        type: "Coffee",
        energy: 10
      };
      
      //m1.eat(c1);
    </pre>
    <script>
      // this 사용
      let objFood = {};
      objFood.name = "0sin";
      objFood.weight = 45;
      objFood.eat = function(food) {
        console.log(this.name + "이 " + food + "를(을) 먹었습니다.");
        this.weight += 1;
      };

      // json 표기법
      let objAlcohol = {
        "name": "0sin",
        "hp": 100,
        "power": 10,
        "attack": function(target) {
          target.hp -= this.power;
        }
      };

      // objAlcohol.attack(objAlcohol); //셀프 공격
      // objAlcohol {name: "0sin", hp: 90, power: 10, attack: ƒ} //체력이 10 깎임
    </script>

    <br><br>
    <h3>연습문제: 소수출력하기</h3>
    <p>1 - 10000 사이의 소수를 화면에 출력하는 프로그램을 작성해 봅시다.</p>
    <p>객체와 메소드를 사용</p>
    <script>
      numbers = {}; //객체
      numbers.all = []; 
      numbers.addAll = function(max_num) { // 2부터 max-num까지의 모든 숫자를 this.all 배열에 넣기
        for (let i=2; i<=max_num; i++) {
          this.all.push(i);
        }
      };

      numbers.prime = [];
      numbers.isPrime = function(number) { // 소수라면 true, 아니면 false return
        for (let i=2; i<number; i++) {
          if(number % i === 0) {
            return false;
          }
        }
        return true;
      };

      numbers.calcPrimes = function() { //해당하는 숫자를 판별, this.prime 배열에 넣기
        for (let i=0; i<this.all.length; i++) {
          let n = this.all[i]; //all에 대한 값 변수 따로 선언해주기
          if (this.isPrime(n)) { //조건식에 함수 들어갈수 있다... 대박적
            this.prime.push(n)
          }
        }
      }

      numbers.getAllPrimes = function() { //화면에 출력
        let ret = '';
        ret += `<p>전체 소수의 갯수: ${this.prime.length}개 </p><br>`;
          // for (var i = 0; i < this.prime.length; i++) {
          //   ret += `${i+1}번째 소수: ${this.prime[i]}<br>`;
          // }
          return ret;
      };

      numbers.addAll(10000);
      numbers.calcPrimes();
      document.write(numbers.getAllPrimes());
    </script>
  </div>

  <!-- 4. 구구단 구현 2 -->
  <div class="chapter">
    <h2>4. 구구단 구현 2</h2>
    <h3>2단: 배열로 구구단 다시 구현</h3>
    <p>구구단 결과을 배열에 저장한 후 배열의 결과를 출력한다.</p>
    <script>
      var gugu2Again = [];
      var length = 9;
      for(var i=1; i <= length; i++) {
          // 계산 결과를 배열에 저장
          gugu2Again.push(2 * i);
      };

      for(var i=1; i <= length; i++) {
          // 배열의 내용을 출력 
          console.log("2 * "+ i + " = " + gugu2Again[i-1]);
      };
    </script>

    <br><br>
    <h3>구구단 전체 배열로 출력</h3>
    <p>이중 루프로 구현</p>
    <script>
      let guguAllAgain = [];
      let length = 9;

      for (let n=2; n <= length; n++) {
          // calculeate
        for(let i=1; i <= length; i++) {
            // 계산 결과를 배열에 저장
            guguAllAgain[i] = n * i; 
        };

        document.write(n + "단 출력하기<br>");
        // print
        for(let i=1; i <= length; i++) {
            // 배열의 내용을 출력
            let str = "";
            str += n;
            str += " * ";
            str += i;
            str += " = ";
            str += guguAllAgain[i];
            str += "<br>";
            document.write(str);
        };
      }
      console.log(guguAllAgain); //guguAllAgain[0]은 empty
    </script>

    <br><br>
    <h3>함수를 활용해 구구단을 구현</h3>
    <p>함수를 활용해 반복적으로 발생하는 코드를 줄인다.</p>
    <p>공부를 위해 메인함수를 사용해 본다: 전역변수 사용을 줄일수 있다.</p>
    <script>
      // 숫자 num을 넣으면 num 구구단 값을 배열로 갖는 함수
      function calculrate(num) {
        var ret = [];
        for (var i = 1; i <= 9; i++) {
          // 계산 결과를 배열에 저장
          ret[i-1] = num * i;
        }
        return ret;
      }

      //num단의 결과 ret 배열을 출력하는 함수
      function print(num, ret) {
        // 계산 결과를 화면에 출력
        document.write("<p>" + num + "단</p>");
        for (let i=1; i<=9; i++) {
          document.write(`${num} X ${i} = ${ret[i-1]} <br>`);
        }
      }

      function main() {
        // 나머지 코드들은 여기에
        for (let n=2; n<=9; n++) { 
          // let result = calculrate(n); 
          // print(n, result);
          print(n, calculrate(n));
        }
      }
      main();
    </script>

    <br><br>
    <h3>객체와 메소드를 사용해서 구구단을 구현</h3>
    <p>main() 메소드는 프로그램을 시작하는 역할을 한다.</p>
    <p>함수를 구구단 객체의 메소드로 변경한다.</p>
    <script>
      const ex = {};
      ex.name = "crong";
      ex.money = 50;
      console.log(ex);
      
      ex.work = function(hour) { //work는 ex의 메소드
        this.money += 6000 * hour; //'나'의 돈은
      }
      ex.work(11);
      console.log(ex);


      // 구구단 최종
      let guguFinal = {};
      guguFinal.result = [];
      guguFinal.currentNum = -1;

      guguFinal.calculate = function(num) {
        this.currentNum = num;
        for (var i = 0; i < 9; i++) {
          this.result[i] = num * (i + 1);
        }
      }

      guguFinal.print = function() {
        document.write("<p>" + this.currentNum + "단</p>");
        for (let i = 0; i < 9; i++) {
          document.write(`${this.currentNum} x ${i + 1} = ${this.result[i]} <br>`);
        }
      }


      function main2() {
        for (let i = 2; i <= 9; i++) { 
          guguFinal.calculate(i);
          guguFinal.print();
        }
      }

      main2();
      console.log(guguFinal);
    </script>

    <br><br>
    <h3>추가미션</h3>
    <p>ex) 팔칠단</p>
    <p>첫번째 숫자 입력: <input type="text" id="guguInput1"></p>
    <p>두번째 숫자 입력: <input type="text" id="guguInput2"></p>
    <button id="guguPlusButton">확인</button>
    <script>
      let guguPlusButton = document.getElementById('guguPlusButton');
      guguPlusButton.addEventListener('click', main3);

      function main3() {
        let num1 = Number(document.getElementById('guguInput1').value);
        let num2 = Number(document.getElementById('guguInput2').value);

        document.write(`<b>${num1} X ${num2} 단 구현하기</b><br>`)
        for (let i = 1; i <= num2; i++) {
          document.write(`${num1} X ${i} = ${num1 * i}<br>`);
        }
      }
    </script>

  </div>

  <!-- 5. 계산기 준비 -->
  <div class="chapter">
    <h2>5. 계산기 준비</h2>
    <h3>배열과 문자열의 메소드 살펴보기</h3>
    <b>복습</b>
    <p>Array (배열, 어레이) - 여러 데이터를 담을 수 있는 자료구조입니다.</p>
    <p>자바스크립트에서 배열은 객체이므로 속성과 메소드를 가집니다.</p>
    <p>배열과 문자열은 유사합니다.</p>
    <p>배열은 mutable, 문자열은 immutable 특징이 있습니다.</p>
    <p>속성: length</p>
    <p>메소드: push(), pop(), unshift(), shift()</p>
    <br>

    <h3>배열의 메소드 더 살펴보기</h3>
    <b>concat()</b>
    <p>concat: 배열 합치기, 문자열도 가능 <em>기존 배열은 변하지 않음</em></p>
    <script>
      let exConcatArr = [1, 2, 3];
      let exConcatArr2 = exConcatArr.concat(4); //하나 넣기
      console.log(exConcatArr2);
      
      let exConcatArr3 = exConcatArr.concat([4, 5, 6]); //여러개 넣기
      console.log(exConcatArr3);

      let exConcatStr = "Hello";
      let exConcatStr2 = exConcatStr.concat(" World"); //str에도 가능
      console.log(exConcatStr2);
    </script>

    <b>join()</b>
    <p>배열을 문자열로 바꿀 때 사용.</p>
    <pre>
      let joinEx = [1, 2, 3, 4, 5];
      joinEx.join(); // "1, 2, 3, 4, 5"
    </pre>
    <script>
      let joinEx = [1, 2, 3, 4, 5];
      let joinExArrToStr = joinEx.join();
      let joinExArrToStr2 = joinEx.join("");
      console.log(joinExArrToStr); // "1, 2, 3, 4, 5"
      console.log(joinExArrToStr2); // "12345"
    </script>

    <b>split()</b>
    <p>문자열을 문자의 배열로 나누고 싶을 때 사용하는 메소드. (<->join())</p>
    <pre>
      let let splitEx = "split";
      splitEx.split(""); // [s, p, l, i, t]
    </pre>
    <script>
      let splitEx = "split";
      let splitExStrToArr = splitEx.split(""); //"" 해줘야 한자씩 들어감
      console.log(splitExStrToArr); // [s, p, l, i, t]
      let splitEx2 = "hello, world a-b-c";
      console.log(splitEx2.split()); // ["hello, world a-b-c"]
      console.log(splitEx2.split("")); // ["h", "e", "l", "l", "o", ",", " ", "w", "o", "r", "l", "d", " ", "a", "-", "b", "-", "c"]
      console.log(splitEx2.split(" ")); // ["hello,", "world", "a-b-c"]
      console.log(splitEx2.split(",")); // ["hello", " world a-b-c"]
      console.log(splitEx2.split("-")); // ["hello, world a", "b", "c"]
    </script>
    
    <b>indexOf(), lastIndexOf()</b>
    <p>배열이나 문자열안의 원소를 가지고 인덱스를 찾을 수 있음</p>
    <pre>
      var a = [10, 20, 30, 40, 10, 50];
      a.indexOf(10); // 0 : 배열 첫번째에 있음
      a.indexOf(65535); // -1 : 없음
      a.lastIndexOf(10); // 4 : 배열 뒤에서부터 찾음 
    </pre>
    <script>
      let indexofEx = [10, 20, 30, 40, 10, 50];
      console.log(indexofEx.indexOf(10)); // 0 : 배열 첫번째에 있음
      console.log(indexofEx.indexOf(65535)); // -1: 없음
      console.log(indexofEx.lastIndexOf(10)); // 4 : 배열 뒤에서부터 찾음 
    </script>

    <b>slice()</b>
    <p>사용법: slice(startIndex, endIndex)</p> 
    <p>기존 배열을 잘라서 새로운 배열을 만듦.</p> 
    <b>기존 배열은 변하지 않습니다. = immutable 이므로 문자열에도 사용 가능</b> 
    <p>startIndex 위치부터 endIndex 직전의 위치까지 자르고, endIndex의 원소는 포함되지 않음.</p>
    <pre>
      a = [1, 2, 3, 4, 5];
      a.slice(2, 4); //[3, 4]: [0]부터 count
    </pre>
    <script>
      let sliceEx = [10, 20, 30, 40, 10, 50];
      console.log(sliceEx.slice(2, 4)); // [30, 40]
      console.log(sliceEx); // 원본 안바뀜
      let sliceEx2 = sliceEx.slice(3, 6); 
      console.log(sliceEx2); // [40, 10, 50]: 마지막 직전까지 자름 ->[start, arr.length=마지막원소까지 추출] 
    </script>

    <b style="color:crimson">slice()</b>
    <p>사용법: splice(startIndex, numElement)</p> 
    <p>배열을 startIndex부터 numElement <b>개수</b>만큼 잘라냅니다.</p>
    <b>잘라낸 원소들은 원본 배열에서 사라집니다.</b> 
    <pre>
      a = [1, 2, 3, 4, 5];
      b = a.splice(2, 4); //[3, 4]
      console.log(a) //[1, 2, 5]
    </pre>
    <script>
      let spliceEx = [10, 20, 30, 40, 10, 50];
      let spliceEx2 = spliceEx.splice(2, 4); //[2]부터 "4개" 자르겠다
      console.log(spliceEx); // 원본 바뀜, [10, 20]
      console.log(spliceEx2); // // [30, 40, 10, 50]
    </script>

    <h3>조건문 2: switch-case</h3>
    <b>문법</b>
    <pre>
      var value;
      switch(value) {
          case 값1:
          //value == 값1일 경우 실행할 코드
          break;
          case 값2:
          //value == 값2일 경우 실행할 코드
          break;
          //...
          default:
          //위쪽에 해당되지 않는 경우 실행할 코드
      }

      Q: 점수가 10점이면 A, 9점이면 B, 그 외에는 C를 출력하는 코드를 작성하세요.

      if로 구현
      var score = prompt('점수를 입력하세요');
      if (score === 10) {
          console.log('A');
      } else if (score == 9) {
          console.log('B');
      } else {
          console.log('C');
      }

      switch-case 로 구현
      var score = prompt('점수를 입력하세요');
      switch (score) {
          case 10:
          console.log('A');
          break;
          case 9:
          console.log('B');
          break;
          default:
          console.log('C');
      }
    </pre>
  

    <h3>객체의 생성자 살펴보기</h3>
    <b>복습</b>
    <p>객체는 유지 보수를 쉽게 하기 위해서 값들을 묶어 놓은 것으로, 속성과 메소드를 가집니다.</p>
    <pre>
      var p1 = {
        "name": "honux",
        "eat": function(food) {}
      };
    </pre>

    <br>
    <b>생성자로 여러 객체를 쉽게 만들기</b>
    <p>비슷한 객체를 여러 개 만들 때는 객체를 생성하는 함수를 이용합니다.(쌤: 저글링 200마리 만들때 하나씩 쓰고 있으면 귀찮으니까...ㅋㅋㅋ)이 때 객체를 생성하는 함수를 생성자라고 한다. 생성자는 관례상 대문자로 시작하는 경우가 많다.</p>
    <pre>
    //휴면 클래스를 정의하는 함수 = 생성자 
    var Human = function(name, hp, power) {
      this.name = name; //이름을 객체자신(나, this)의 이름으로 넣는다.
      this.hp = hp;
      this.power = power;
      this.attack = function(target) {
        console.log(this.name + "이 " + target.name + "을 공격했다.")
        target.hp -= this.power;
      };
      this.show = function() {
        console.log("%s %d %d %d", this.name, this.hp, this.mp, this.power);
      };
    };
    </pre>

    <p>생성자를 이용해서 객체를 만들 때는 new 키워드를 사용합니다.</p>
    <pre>
    var m1 = new Human("Honux", 100, 10);
    var m2 = new Human("Crong", 999, 1);
    m1.attack(m2);
    m2.attack(m1);
    m1.show();
    m2.show();
    </pre>
    <p>위 코드에서 m1은 객체 또는 인스턴스라고 합니다. m1은 그리고 참조 변수입니다. 참조 변수에 대해서는 다음에 다시 설명합니다.</p>

    <br>
    <b>생성자를 사용하는 이유</b>
    <p>객체를 하나만 만들 때는 간단히 json 표기법(var a = {};)으로 만듭니다.</p>
    <p>여러 객체를 만들고 싶을 때는 생성자를 통해서 만듭니다.</p>

    <br>
    <br>예제</br>
    <p>Food(name, energy) 생성자를 만들어 봅시다.</p>
    <p>eat(food) 메소드를 Human() 생성자 안에 추가해 봅시다.</p>
    <p>도너츠 객체를 생성해서 휴먼 객체에게 먹여 봅시다.</p>
    <pre>
      let Food = function(name, energy) {
        this.name = name;
        this.energy = energy;
      }
    </pre>
      
      
      
    <script>
      var p1 = {
        "name": "honux",
        "eat": function(food) {}
      };
      console.log(p1);

      // Human 함수 생성
      var Human = function(name, hp, power) {
        this.name = name; //이름을 객체자신(나, this)의 이름으로 넣는다.
        this.hp = hp;
        this.power = power;
        this.attack = function(target) {
          console.log(this.name + "이 " + target.name + "을 공격했다.")
          target.hp -= this.power;
        };
        this.show = function() {
          console.log("[%s] %d %d", this.name, this.hp, this.power);
        };
      };

      // man1=참조변수, Human class에 instance man1이다. (인간의 인스턴스 '나')
      // 객체의 변수는 참조변수다.
      var man1 = new Human("Honux", 100, 10); 
      var man2 = new Human("Crong", 999, 1);
      man1.attack(man2);
      man2.attack(man1);
      man1.show();
      man2.show();


      // FOOD 생성자 만들기
      let Food = function(foodName, foodEnergy) {
        this.name = foodName; //'나'의 이름은
        this.energy = foodEnergy; //'나'의 체력은
        this.feed = function(human) { //'나'의 할일은: 먹인다. 사람에게. 
          human.hp += this.energy;
        };
      }

      // 도너츠 객체 만들기
      let donut = new Food('donut', 500);
      console.log(donut);

      // 도너츠 man1에게 먹이기
      donut.feed(man1);
      man1.show();
    </script>

    <h3>참조 변수와 Call by Reference</h3>
    <h3>값에 의한 전달 이해하기</h3>
    <b>일반 변수 | 참조 변수</b>
    <p>기본 타입을 변수에 할당하면 일반 변수, 객체를 변수에 할당하면 참조 변수가 된다.</p>

    <b>일반 변수에서 값 복사 및 바꾸기</b>
    <p>일반 변수는 <b>값만</b> 저장하고 다른 변수에 언제나 독립적으로 존재합니다.</p>
    <pre>
      var a = 5;
      var b = a;
      a === b
      b = 10
      a === b
    </pre>
    <p>위 코드에서 a와 b는 처음에 값은 같지만 사실은 다른 변수입니다.</p>

    <b>참조 변수의 동작 방식 이해하기</b>
    <p>참조 변수라는 것은 객체에 대한 별명 같은 것. 같은 사람을 이름, 별명, 다양한 호칭으로 부르는 것과 비슷. 우리가 객체를 만들면 객체가 생기고 변수에는 그 객체의 참조를 할당한다</p>
    <pre>
      var m1 = {name: "honux", age: 25};
      var m2 = m1;
      m1 === m2;
      m2.name = "crong";
      m1;
      m1 === m2;
    </pre>
    <p>일반 변수와는 전혀 다른 결과가 나왔죠? 왜 그런지는 나중에 저절로 알게 됩니다. 일단 이게 참조 변수구나하고 기억해 둡시다.
    </p>
    <script>
      // 일반변수는 값이 !복사!, 변형된다.
      let nNum1 = 1; //일반변수
      let nStr1 = "hello"; //일반변수
      let nBoolean = true; //일반변수

      let nNum2 = nNum1; //nNum1의 '값'을 읽어서 넣어줌
      console.log(nNum2); //1
      console.log(nNum1 === nNum2); //true
      
      nNum1 = 10;
      console.log(nNum1); //10
      console.log(nNum2); //1
      console.log(nNum1 === nNum2); //false

      let nStr2 = nStr1;
      console.log(nStr1); //hello
      console.log(nStr2); //hello
      console.log(nStr1 === nStr2); //true
      
      nStr1 = "hell";
      console.log(nStr1); //hell
      console.log(nStr2); //hello
      console.log(nStr1 === nStr2); //false
      
      
      // 참조변수. 값이 하나를 가리키고 있다.
      let rArr1 = [1, 2, 3] //참조변수
      let rObj1 = {} //참조변수
      
      let rArr2 = rArr1; //둘이 같은 배열 객체를 '가리키고' 있다.
      console.log(rArr1); //[1, 2, 3]
      console.log(rArr2); //[1, 2, 3]
      console.log(rArr1 === rArr2); //true

      rArr1.push(10);
      console.log(rArr1); //[1, 2, 3, 10]
      console.log(rArr2); //[1, 2, 3, 10]
      console.log(rArr1 === rArr2); //true: 두놈은 완전히 같은 놈이다~

      let rObj2 = rObj1;
      console.log(rObj1); //{}
      console.log(rObj2); //{}
      console.log(rObj1 === rObj2); //true
      
      rObj1.name = "0sin";
      console.log(rObj1); //{name: 0sin}
      console.log(rObj2); //{name: 0sin}
      console.log(rObj1 === rObj2); //true      
    </script>

    <br>
    <b>함수 호출시의 변수</b>
    <p>두 코드의 동작 차이를 봅시다.</p>

    <b>값 전달</b>
    <pre>
      var foo_v = function(v) {
        v = v * 2;
        console.log(v);
      }
      
      var a = 10;
      foo_v(a);
      console.log(a);
    </pre>
    
    <br>
    <b>참조 전달</b>
    <pre>
      var foo_r = function(ref) {
        ref.v = ref.v * 2;
        console.log(ref);
      }
      
      var p = {name: "Dora", v: 99};
      foo_r(p);
      console.log(p);
    </pre>

    <b>요약</b>
    <p>값 전달 변수는 함수 내부에서 값을 바꿔도 외부에서는 그대로.</p>
    <p>참조 전달 변수는 함수 내부에서 값을 바꾸면 외부의 객체도 값이 바뀜.</p>

    <script>
      // Call By Value
      // 값에 의한 전달
      var foo_v = function(v) { //값인 10만 들어감~
        v = v * 2; // 20
        console.log(v);
      }
      
      var a_v = 10;
      foo_v(a_v); // 20
      console.log(a_v); // 10


      // Call By Referrence
      // 참조에 의한 전달
      var foo_r = function(people) {
        people.weight = people.weight - 2;
        console.log(people.weight); // 58
      }
      
      var people1 = {name: "Dora", weight: 60};
      foo_r(people1); //58
      console.log(people1.weight); //58

      var rArr3 = [1, 2, 3, 4, 5];
      var append = function(arr, v) {
        arr.push(v);
      };

      append(rArr3, 10);
      console.log(rArr3);
    </script>    

    <h3>Prototype</h3>
    <b>prototype</b>
    <p>생성자로 만든 객체는 프로토타입이라는 속성을 가집니다. 자바스크립트로 객체 지향 프로그래밍을 하기 위해서는 프로토타입을 잘 이해해야 합니다. 일단 우리는 프로토타입을 이용해서 메소드를 생성하려 합니다. 이렇게 하면 메모리를 절약하고 효율적으로 객체의 메소드를 생성할 수 있습니다.</p>
    <pre>
      function Human(name, hp, mp, power) {
        this.name = name; //m1.name = name;
        this.hp = hp;
        this.mp = mp;
        this.power = power;
      }
      
      Human.prototype.attack = function(target) {
          target.hp -= this.power;
      };
    </pre>

    <script>
      function Human2(name, hp, mp, power) {
        this.name = name; //m1.name = name;
        this.hp = 100;
        this.mp = 80;
        this.power = power;
      }
      
      Human2.prototype.attack = function(target) {
          target.hp -= this.power;
      };

      var m1 = new Human2("0sin", "" , "", 20);
      console.log(m1); // Human2 {name: "0sin", hp: 100, mp: 80, power: 20}
      m1.attack(m1);
      console.log(m1); // Human2 {name: "0sin", hp: 80, mp: 80, power: 20} :hp 20 감소
    </script>
  
    <br>
    <b>배열과 객체</b>
    <p>객체의 속성값이 배열이 될 수 있습니다. 배열 안에 값들이 객체가 될 수 있습니다.</p>
    <pre>
      var m1 = {'no': 1, 'scores': [100, 99]};
      var m2 = {'no': 2, 'scores': [100, 99]};
      var arr1 = [m1, m2];
    </pre>
    <b>배열, 객체와 참조변수</b>
    <p>객체를 변수에 할당하면 그 변수는 참조 변수가 됩니다. 배열도 객체이므로 배열을 변수에 할당하면 역시 참조 변수가 됩니다. 함수 호출시 참조 변수를 매개 변수로 전달하면 함수 내부에서 변경한 값이 외부에서도 변경된다는 것 꼭 기억하세요.</p>
    <script>
      m1.item = ["sword", "shield", "potion"];
      console.log(m1);
      console.log(m1.item) //["sword", "shield", "potion"]
      console.log(m1.item[0]) //sword

      var nu1 = {'no': 1, 'scores': [100, 99]};
      var nu2 = {'no': 2, 'scores': [100, 99]};
      var nuArr = [nu1, nu2];
      console.log(nuArr);
      
      nu1.scores[0] = 0; //참조변수라서 값이 바뀜
      console.log(nuArr[0]); //{'no': 1, 'scores': [0, 99]}

      var m2 = new Human2("shooky", "", "", 1);
      var m3 = new Human2("Ian", "", "", 99);
      m1.firends = [m2, m3];
      m2.friend = m1;
      console.log(m1.firends[0]);
      console.log(m2.friend);
      console.log(m2.friend.firends[0].friend); //ㅋㅋㅋㅋㅋ
    </script>

    <h3>DOM과 HTML</h3>
    <b>HTML</b>
    <p>HyperText Markup Language</p>
    <p>WWW의 3요소 중 하나</p>
    <p>팀 버너스리에 의해 만들어 졌다.</p>
    <br>
    <b>엘리먼트 (Element)</b>
    <p>여는 태그와 닫는 태그로 이루어짐</p>
    <p>태그 사이에 콘텐츠를 가짐</p>
    <p>태그 안에 속성과 속성의 값을 가짐</p>
    <p>닫는 태그가 없는 태그도 있다. (img, br, input)</p>
    <br>
    <b>속성(Attributes)</b>
    <p>객체의 속성과 비슷하게 엘리먼트도 속성을 가질 수 있습니다.</p>
    <br>
    <b>블록 엘리먼트</b>
    <p>p, h1, div 처럼 줄이 바뀌는 엘리먼트</p>
    <br>
    <b>인라인 엘리먼트</b>
    <p>span, img, input, button, a 처럼 줄바뀜이 없는 엘리먼트</p>
    <br><br>
    <h3>HTML과 JS 분리하기</h3>
    <b>dom.html</b>

    <b>dom_test.js</b>
    <pre>
      var msg = "Hello";
      alert(msg);
    </pre>

    <br>
    <br>DOM (Document Object Model)</br>
    <p>문서를 객체를 이용해서 계층 구조로 표현함</p>
    <p>표준: W3CDOM</p>
    <p>구현체: Gecko, Webkit 등</p>
    <br>
    <br>html 객체</br>
    <b>HTML 문서도 객체로 간주된다.</b>
    <p>window: 최상위 객체</p>
    <p>document: dom의 최상위 객체이면서 window의 하위 객체</p>
    <pre>
      var list = document.getElementsByTagName('h1');
      list[0].innerHTML;
      list[0].innerHTML = "Hello";
    </pre>
    <pre>
      var list = document.getElementById('main');
      main.innerHTML = "Hello";
    </pre>

    <br>
    <b>JS로 DOM 제어하기</b>
    <p>모든 HTML 엘리먼트는 객체이므로 다른 객체와 마찬가지로 JS로 제어가 가능합니다.</p>

    <br>
    <b>DOM 객체의 값 바꾸기</b>
    <pre>
      var element = document.getElementById('id')
      element.innerHTML = '값'
    </pre>

    <b>아래 문장은 JS로 dom을 제어한 것이다</b>
    <p id="test"></p>
    <script>
      var para = document.getElementById("test");
      para.innerHTML = "Hello World!";
    </script>
  

    <h3>DOM으로 버튼 추가해 보기</h3>
    <b>DOM을 이용해 html 객체 추가하기</b>
    <div id="domex">메뉴판 예제</div>
    <script>
      var domEl = document.getElementById('domex');
      var menu = document.createElement('ul');  
      menu.id = 'menupan';

      var item1 = document.createElement('li');
      item1.id = 'menu1';
      item1.innerHTML = "설렁탕";

      var item2 = document.createElement('li');
      item2.id = 'menu2';
      item2.innerHTML = "추어탕";

      menu.appendChild(item1);  
      menu.appendChild(item2);  

      domEl.appendChild(menu);
    </script>

    <b>input 과 button 샘플</b>
    <input type='text' id='domInput'>
    <button id='btn1' onclick='read()'>click</button>
    <script> 
        var read = function() {
            var domInput = document.getElementById('domInput');
            console.log(domInput.value);
        };
    </script>
  </div>




  <!-- 6. 계산기 구현-->
  <div class="chapter">
    <h2>6. 계산기 구현</h2>
    <h3>문자열 계산기</h3>
    <div id="output1"></div>
    <script>
      function calculator1() {
          console.log("Calculator1");
          var out = document.getElementById("output1");
          out.innerHTML = "계산기 구현하기";
          
          console.log(10 + 3);            
          console.log(10 * 3);            
          console.log(10 / 3);            
          console.log(10 - 3);            
      }
    calculator1();
    </script>
    
    <br><br>
    <h3>값 입력 및 사칙연산 - 변수</h3>
    <div id="output2">
      첫번째 수: <input type="text" id="input1"><br>
      두번째 수: <input type="text" id="input2"><br>
      <button id="button1">결과확인</button><br>
      <p id="c_result1">결과 표시</p>
    </div>
    <script>
      var button1 = document.getElementById("button1");
      button1.addEventListener('click', calculator2)

      function calculator2() {
          console.log("Calculator2");
          var num1 = Number(document.getElementById("input1").value);
          var num2 = Number(document.getElementById("input2").value);
          
          // document.write(num1 + " + " + num2 + " = " + (num1 + num2) + "<br>");            
          // document.write(num1 + " * " + num2 + " = " + (num1 * num2) + "<br>");            
          // document.write(num1 + " / " + num2 + " = " + (num1 / num2) + "<br>");            
          // document.write(num1 + " - " + num2 + " = " + (num1 - num2) + "<br>");            

          var str = "";
          str += "더하기: " + (num1 + num2) + "<br>";
          str += "빼기: " + (num1 - num2) + "<br>";
          str += "곱하기: " + (num1 * num2) + "<br>";
          str += "나누기: " + (num1 / num2) + "<br>";
          
          var out = document.getElementById('c_result1');
          out.innerHTML = str;     
      }
    </script>

    <br><br>
    <h3>값 입력 및 사칙연산 - 조건문</h3>
    <p>switch 사용</p>
    <div id="output3">
      첫번째 수: <input type="text" id="input3"><br>
      두번째 수: <input type="text" id="input4"><br>
      연산자 기호 입력: <input type="text" id="input5"><br>
      <button id="button2">결과확인</button><br>
      <p id="c_result2">결과 표시</p>
    </div>
    <script>
      var button1 = document.getElementById("button2");
      button1.addEventListener('click', calculator3)

      function calculator3() {
        console.log("Calculator3");
        var num1 = Number(document.getElementById("input3").value);
        var num2 = Number(document.getElementById("input4").value);
        var op = document.getElementById("input5").value;
        var str = "";

        switch (op) {
          case "+":
          str += "더하기: " + (num1 + num2) + "<br>";
          break;
          case "-":
          str += "빼기: " + (num1 - num2) + "<br>";
          break;
          case "*":
          str += "곱하기: " + (num1 * num2) + "<br>";
          break;
          case "/":
          str += "나누기: " + (num1 / num2) + "<br>";
          break;
          default:
          str += "잘못 입력하셨습니다.";
        }
        var out2 = document.getElementById('c_result2');
        out2.innerHTML = str;   
      }
    </script>

    <br><br>
    <h3>여러 값 입력 및 사칙연산 - 반복문</h3>
    <p>prompt()를 이용</p>
    <p>한 번에 2개의 숫자 값만 사칙연산을 하는 것이 아니라 여러 개의 사칙연산이 가능해야 한다.(무한루프 경험)</p>
    <p>사칙연산 기호 대신 "q"라는 문자를 입력하면 최종 계산 결과를 출력하고 프로그램을 종료한다.</p>
    <p>while(true)와 같이 구현하면 무한히 값을 입력받을 수 있다.</p>
    <p>while(true)로 실행하고 있는 프로그램을 종료하려면 break 키워드를 사용하면 된다. 즉, "quit"이라는 문자열을 입력하는 경우 break를 사용해 프로그램을 종료할 수 있다.</p>
    <div id="output4">
      <p id="c_result3" style="color: orange">결과 표시</p>
    </div>
    <script>
      /*
      function calculator4() {
        console.log("Calculator4");
        var n1 = Number(prompt("첫번째 숫자를 입력해 주세요."));    
        var out = document.getElementById('c_result3');

        var op, n2;
        var result = n1;
        var n = 2;

        while(true) {
            op = prompt("연산자를 입력해 주세요.");

            if (op === 'q') {
                break;
            }

            n2 = Number(prompt(n + "번째 숫자를 입력해 주세요."));                

            if (op === '+') {
                result += n2;
            } else if (op === '-') {
                result -= n2;
            } else if (op === '*') {
                result *= n2;
            } else if (op === '/') {
                result /= n2;
            } else {
                result = "중간오류";
                break;
            }
            n++;
        }           
        out.innerHTML = "최총 결과값은 " + result + "입니다";  
      }
      calculator4();
      */
    </script>

    <h3>함수를 활용해 사칙연산 구현</h3>
    <p>메인 함수, 사용자의 값을 입력하는 함수, 출력하는 함수 등 함수로 코드를 나누어 구현한다.</p>
    <p>사용자의 값을 입력하는 구현은 첫 번째 숫자 값, 사칙연산 기호 및 quit, 두 번째 숫자 값 입력으로 나뉜다.</p>
    <div id="output5">
      <p id="c_result4" style="color: orange">결과 표시</p>
    </div>
    <script>
      /*
        fucntion getFirstValue()
        function getSecondValue() 
        function getOperator()
        function calculate()
        function print()
        function main()
        */

       /*
        function getFirstValue() {
            var num1 = Number(prompt("첫번째 값을 입력해 주세요."));
            return num1;
        }
        
        var n = 2;        
        function getSecondValue() {            
            var num2 = Number(prompt( n + "번째 값을 입력해 주세요."));
            n++;
            return num2;
        }

        function getOperator() {
            while(true) {
                var op = prompt("연산자를 입력해 주세요.");
                if (op === "+" || op === "-" || op === "*" || op === "/" 
                    || op === "q" ) {
                    break;
                } else {
                    alert("올바른 연산자를 입력해 주세요.");
                }
            }            
            return op;
        }      

        function calculate(first, second, op) {
            var ret;
            switch(op) {
                case "+":
                ret = first + second;
                break;
                case "-":
                ret = first - second;
                break;
                case "*":
                ret = first * second;
                break;
                case "/":
                ret = first / second;
                break;           
            }
            return ret;
        }

        function print(value) {
            return "최종 결과값은 " + value + "입니다.";
        } 

        function cMain() {
            var result = getFirstValue();            
            while(true) {
                var op = getOperator();
                if (op === 'q') {
                    break;
                }
                var num = getSecondValue();
                result = calculate(result, num, op);
            }
            var output = document.getElementById('c_result4');
            output.innerHTML = print(result);   
        }
        cMain();
        */         
    </script>

    <h3>객체를 활용해 사칙연산 구현</h3>
    <p>사용자의 값을 입력하는 객체, 사칙연산을 구현하는 객체, 출력하는 객체를 이용해서 프로그램을 구현한다.</p>
    <p>main 함수를 사용한다.</p>
    <pre>
      힌트
      input = {}
      input.getFirstValue = function();
      input.getSecondValue= function();
      intput.getOperator = function();


      output = {}
      output.print = function();

      calculator = {}
      calculator.calculate = function();
    </pre>
    <div id="output6">
      <p id="c_result6" style="color: orange">결과 표시</p>
    </div>

    <script>
      /*
      var cInput = {count:2};
      
      cInput.getFirstValue = function() {
          var n = Number(prompt("첫번째 값을 입력해 주세요."));
          return n;
      };        
      
      cInput.getSecondValue = function() {            
          var num2 = Number(prompt( this.count + "번째 값을 입력해 주세요."));
          this.count++;
          return num2;
      };

      cInput.getOperator = function() {
          while(true) {
              var op = prompt("연산자를 입력해 주세요.");
              if (op === "+" || op === "-" || op === "*" || op === "/" 
                  || op === "q" ) {
                  break;
              } else {
                  alert("올바른 연산자를 입력해 주세요.");
              }
          }            
          return op;
      };      
      
      calculator = {};
      calculator.calculate = function(first, second, op) {
          var ret;
          switch(op) {
              case "+":
              ret = first + second;
              break;
              case "-":
              ret = first - second;
              break;
              case "*":
              ret = first * second;
              break;
              case "/":
              ret = first / second;
              break;           
          }
          return ret;
      }
      
      var output = {};
      output.out = document.getElementById('c_result6');

      output.print = function(value) {
          this.out.innerHTML =  "최종 결과값은 " + value + "입니다.";
      }; 

      function cMain2() {
          var result = cInput.getFirstValue();            
          while(true) {
              var op = cInput.getOperator();
              if (op === 'q') {
                  break;
              }
              var num = cInput.getSecondValue();
              result = calculator.calculate(result, num, op);
          }
          output.print(result);   
      }
      cMain2(); 
      */       
    </script>

    <h3>한 줄로 입력받아 처리하기</h3>
    <p>문자열 계산기는 사칙연산의 계산 우선순위가 아닌 입력 값에 따라 계산 순서가 결정된다. 즉, 수학에서는 곱셈, 나눗셈이 덧셈, 뺄셈 보다 먼저 계산해야 하지만 이를 무시한다.</p>
    <p>입력은 텍스트로 한 줄로 받고 숫자와 연산자 사이는 스페이스로 분할한다. 2 + 3 * 5 처럼 입력을 받아 처리한다</p>
    <p>문자열의 split(" ")을 이용하면 요구사항대로 구현할 수 있다.</p>
    <p>eval(str)을 쓰지 말 것</p>

    <div>
      <input type="text" id="input7"><br>
      <button onclick="calc7()">확인</button>
    </div>
    <div id="output7">결과가 여기에 나옵니다.</div>
  <script>        
      var input = {};
      
      input.init = function(str) {
          this.list = str.split(" ");   
      };

      input.empty = function() {
          return this.list.length == 0;
      };

      input.getValue = function() {
          var str = this.list.shift();
          var n = Number(str);
          return n;
      };        

      input.getOperator = function() {
          var op = this.list.shift();
          if (op === "+" || op === "-" || op === "*" || op === "/") {
              return op;
          } else {
              return "$";
          }            
      };      
      
      calculator = {};
      calculator.calculate = function(first, second, op) {
          var ret;
          switch(op) {
              case "+":
              ret = first + second;
              break;
              case "-":
              ret = first - second;
              break;
              case "*":
              ret = first * second;
              break;
              case "/":
              ret = first / second;
              break;  
              default:
              return NaN;         
          }
          return ret;
      }
      
      var output = {};
      output.out = document.getElementById('output7');

      output.print = function(value) {
          this.out.innerHTML =  "최종 결과값은 " + value + "입니다.";
      };    

      function calc7() {
          var str = document.getElementById('input7').value;
          input.init(str);
          var result = input.getValue();
          while (!input.empty()) {
              var op = input.getOperator();
              var second = input.getValue();
              result = calculator.calculate(result, second, op);
          }            
          output.print(result);
      }       
  </script>

  </div>


  <!-- 7. 숫자 퍼즐 준비-->
  <div class="chapter">
    <h2>7. 숫자 퍼즐 준비</h2>
    <h3>Scope란?</h3>
    <p>변수의 유효범위</p>

    <br>
    <b>전역 변수</b>
    <p>함수 외부에서 선언된 변수 많이 쓰면 좋지 않습니다. 가급적이면 사용하지 않는 게 좋습니다.</p>

    <br>
    <b>지역 변수</b>
    <p>함수 안에서 선언된 변수 외부에서 사용할 수 없다.</p>

    <br>
    <b>자동 전역 변수</b>
    <p>함수 안에서 var 없이 선언하면 자동 전역 변수가 된다. 절대로 이렇게 하면 안 됩니다!</p>

    <br>
    <b>매개변수의 스코프</b>
    <p>함수의 매개 변수는 자동으로 지역 변수 취급</p>

    <br>
    <b>for문 안에서 사용된 변수의 스코프</b>
    <p>언어마다 다른데 자바스크립트어세는 그냥 for문 바깥에서 선언된 것과 동일한 효과입니다.</p>

    <br>
    <b>const와 let</b>
    <p>ES6의 새로 등장한 문법으로 var 와는 조금 다르게 동작합니다. 일반적으로 연습할 때는 const와 let을 쓰는 걸 권장합니다. let은 블록 범위 스코프를 가지고 있습니다.</p>

    <br>
    <b>호이스팅</b>
    <pre>
      console.log(a);

      var a = 10;

      console.log(a);

      //undefined
      //10
    </pre>

    <br>
    <b>클로져(closure)</b>
    <p>클로져는 고급 주제 중 하나입니다. 관심이 있으시면 검색해서 공부해 보세요. 초급에서는 공부 안 해도 되는 주제이지만 중급에서는 꼭 알아야 하는 것 중 하나입니다.</p>

    <script>
      var a00 = 10; //전역변수
      var f00 = function(v) {
        var b00 = 25; //지역변수
        c00 = 100; //자동전역변수 -> 절대 노노임
        console.log(a00);
        console.log(b00);
        console.log(c00);
        console.log(v); //매개변수는 일종의 지역변수와 같다
      }

      for (var p=0; p<5; p++) { //p는 전역변수와 같음
        console.log(p);
      }
      for (let i=0; i<5; i++) { //i는 블록범위 스코프이므로 밖에서 호출할 수 없다.
        console.log(p);
      }
    </script>

    <br><br>
    <h3>재귀란?</h3>
    <p>함수가 함수 안에서 자신을 다시 호출하는 것</p>
    <pre>
    var foo = function() {
      foo();
    } //이러면 브라우져 다운됨
    </pre>

    <br>
    <b>카운트다운 재귀로 구현하기</b>
    <p>일반버전</p>
    <pre>
    var countdown = function(n) {
      for (var i = n; i >= 0; i--) {
          console.log(i);
      }
    };
    
    countdown(10);
    </pre>
    <b>재귀로 구현1</b>
    <pre>
      var countdown2 = function(n) {
        console.log(n);
        countdown2(n - 1);
      };
    </pre>
    <p>위 코드는 종료 조건이 빠져 있기 때문에 무한 루프처럼 종료가 되지 않습니다!</p>
    <p>재귀 함수에 종료 조건 추가</p>
    <pre>
    var countdown2 = function(n) {

      //termination condition
      console.log(n);
      if (n <= 0) {
          return;
      }
  
      countdown2(n - 1);
    };
    </pre>
    <p>재귀에는 반드시 종료조건이 필요하다.</p>
    
    <br>
    <b>왜 재귀를 사용하나?</b>
    <p>재귀를 사용하면 쉽게 풀리는 문제들이 많이 존재하기 때문입니다.</p>
    <p>예를 들어, 알고리즘의 리스트, 트리, 그래프 순회 문제는 재귀로 푸는 게 편합니다.</p>
    <br>
    <b>재귀 vs 일반</b>
    <p>일반 함수가 재귀 함수보다 높은 성능을 보인다.</p>
    <p>모든 재귀 알고리즘은 일반 알고리즘으로 바꿀 수 있다.</p>
    <br>
    <b>그런데 왜?</b>
    <p>재귀 없이 구현하면 성능이 좋아지고 재귀를 사용하면 프로그래머의 능력이 좋아집니다.</p>
    <br>
    <b>재귀로 구현하기 연습</b>
    <p>a부터 b까지 정수를 더해서 리턴해 주는 함수</p>
    <pre>
    var rsum = function(a, b) {
      if (a ==  b) {
          return a;
      }
      return b + rsum(a, b - 1);
    }
    
    var x = rsum(1, 10);
    console.log(x);
    </pre>
    <br>
    <b>재귀로 팩토리얼 구현하기</b>
    <pre>
    fact(3) = 3*2*1;
    var fact = function(n) {
      //implement
    };
    </pre>

    <script>
      var countdown = function(n) {
        for (let i=n; i>0; i--) {
          console.log(i);
        }
        console.log("Fire!");
      }

      countdown(10);

      // COUNTDOWN 재귀함수
      var countdownR = function(n) {
        
        console.log(n);
        if (n <= 0) {
          console.log("땡");
          return;
        }
        countdownR(n - 1); //꼭 매개변수가 달라져야함!
      }
      countdownR(10);


      // a부터 b까지 정수 더하기
      var rSum = function(a, b) {
        if (a > b) {
          return NaN;
        } else if(a === b) {
          return a;
        }
        return b + rSum(a, b - 1);
      }

      // TEXT CODE
      console.log(rSum(1,1) === 1);
      console.log(rSum(1,2) === 3);
      console.log(rSum(2,10) === 54);
      console.log(rSum(1,-1) == 54); //false


      // FACTORIAL
      var fact = function(n) {
        if (n < 0) {
          return NaN;
        }
        if (n === 1 || n === 0) {
          return 1;
        }
        return n * fact(n - 1);
      }
      console.log(fact(1) === 1);
      console.log(fact(2) === 2);
      console.log(fact(3) === 6);
      console.log(fact(0) === 6); //false
      console.log(!fact(-1));

    </script>

    <h3>재귀의 기초2</h3>
    <b>점화식</b>
    <p>재귀나 다이나믹 프로그래밍이라는 걸로 문제를 풀 때 유용하게 사용할 수 있는 수학 공식입니다.</p>
    <br>
    <b>재귀로 피보나치 수열 구현하기</b>
    <p>피보나치 수열이란 오래 된 수학 문제 중 하나입니다. 무인도 토끼 문제로도 알려져 있습니다.</p>
    <pre>
      피보나치 수열의 점화식
      f(0) = 0
      f(1) = 1
      f(n) = f(n-1) + f(n-2)
      
      f(0) = 0, 
      f(1) = 1, 
      f(2) = f(1) + f(0) = 1 + 0 = 1 
      f(3) = f(2) + f(1) = 1 + 1 = 2 
      f(4) = f(3) + f(2) 2 + 1 = 3
    </pre>
    <br>
    <b>재귀로 피보나치 수열을 구현하기</b>
    <p>첫 번째 방법</p>
    <pre>
    function fibo(n) {
      if (n <= 0) {
          return 0;
      }
      if (n == 1) {
          return 1;
      }
      return fibo(n - 1) + fibo(n - 2);
    }
    </pre>
    <p>두 번째 방법 (옵션)</p>
    <pre>
      var arr =[0, 1];

      function fibo_d(n) {
          if(arr[n] == undefined) {
              arr[n] = fibo_d(n - 1) + fibo_d(n - 2);
              }
          return arr[n];
      }
    </pre>
    <p>이런 방법을 다이나믹 프로그래밍(또는 memoization) 기법이라고 합니다.</p>


    <h3>Math 객체</h3>
    <p>기본 전역 객체인 Math 객체는 유용한 속성과 메소드들을 포함하고 있습니다.</p>

    <br>
    <b>속성</b>
    <p>
      Math.E //오일러 상수<br/>
      Math.PI //파이<br/>
      Math.SQRT2 //루트2<br/>
      Math.LN2 //로그</p>
    <br/>
    <b>메소드</b>
    <p>Math.abs(x); //absolute value<br>
      Math.sin(x);<br>
      Math.floor(x); //버림<br>
      Math.ceil(x); //올림<br>
      Math.round(x)<br>
      Math.max(a, b);<br>
      Math.min(a, b);</p>

    <br/>
    <h3>Math.random() 사용해 보기</h3>
    <p>Math.random()은 0과 1 사이의 실수를 리턴합니다. 이를 이용해서 다양한 범위의 정수들을 만들어 낼 수 있습니다. 직접 도전해 보세요!</p>
    <script>
      console.log(Math.abs(-3.7)); //3.7 절댓값
      console.log(Math.ceil(0.91)); //1 올림
      console.log(Math.floor(10.6)); //10 내림
      console.log(Math.round(10.6)); //11 반올림
      console.log(Math.min(2, 3, 4, 115)); //2 최소값
      console.log(Math.max(2, 3, 4, 115)); //115 최대값

      // Math.random()
      // 0 ~ 10 사이의 정수
      Math.ceil(Math.random() * 10);
      
      // 1 ~ 10 사이의 정수
      Math.floor(Math.random() * 10) + 1;


      // -5 ~ 5 사이의 정수
      // 1 ~ 10 사이의 짝수

    </script>



  </div>

  
  <!-- 8. 계산기 구현-->
  <div class="chapter">
    <h2>8. 계산기 구현</h2>
  </div>


  <script>
    const chapter = document.querySelectorAll('.chapter')
    const idx = document.querySelectorAll('.idx')

    idx.forEach((e, i) => e.addEventListener('click', () => {
      chapter.forEach(e => e.style.display = "none");
      chapter[i].style.display = "block";
    }));
  </script>

</body>
</html>